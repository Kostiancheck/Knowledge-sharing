# Terraform

To start with Terraform let's run simple example with Docker.
You can find full Docker tutorial here https://developer.hashicorp.com/terraform/tutorials/docker-get-started

# Install

OS X with brew installation. To install on other OSs
see https://developer.hashicorp.com/terraform/tutorials/docker-get-started/install-cli

1. `brew tap hashicorp/tap`
2. `brew install hashicorp/tap/terraform`
3. `brew update`
4. `brew upgrade hashicorp/tap/terraform`
5. Check if it's installed successfully `terraform -v`
6. (Optional) if you want to enable autocomplete support for your terraform commands
   run `terraform -install-autocomplete`

# Declare infrastructure 📄

The first step is to create [main.tf](main.tf) file with infrastructure description

```hcl
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0.1"
    }
  }
}

provider "docker" {}

resource "docker_image" "nginx" {
  name         = "nginx:latest"
  keep_locally = false
}

resource "docker_container" "nginx" {
  image = docker_image.nginx.image_id
  name  = "tutorial"
  ports {
    internal = 80
    external = 8000
  }
}
```

`terraform {...}` block contains Terraform settings, including the required providers Terraform will use to provision
your infrastructure. For each provider, the source attribute defines an optional hostname, a namespace, and the provider
type. Terraform installs providers from
the [Terraform Registry](https://registry.terraform.io/?product_intent=terraform) by default. In this example
configuration, the docker provider's source is defined as kreuzwerker/docker, which is shorthand for
registry.terraform.io/kreuzwerker/docker.

The `version` attribute is optional, but we recommend using it to constrain the provider version so that Terraform does
not install a version of the provider that does not work with your configuration. If you do not specify a provider
version, Terraform will automatically download the most recent version during initialization.
In versions you can also
use [next operators](https://developer.hashicorp.com/terraform/language/expressions/version-constraints):

- no operator allows only one exact version number. E.g. `version = "1.33.7"`
- `>=`, `>`, `<`, `<=` minimum/maximum provider version. E.g. `version = ">= 1.3.7, < 3.3.7"`
- `!=` Excludes an exact version number
- `~>` allows only the rightmost version component to increment. E.g. `~> 1.33.7` Allows Terraform to install `1.33.8`
  and
  `1.33.9` but not `1.34.0`

The `provider` block configures the specified provider, in this case docker. A provider is a plugin that Terraform uses
to create and manage your resources.
You can use multiple provider blocks in your Terraform configuration to manage resources from different providers. You
can even use different providers together. For example, you could pass the Docker image ID to a Kubernetes service.

Use `resource` blocks to define components of your infrastructure. Resource blocks have two strings before the block:
the resource type and the resource name. In this example, the first resource type is docker_image and the name is nginx.
The prefix of the type maps to the name of the provider. In the example configuration, Terraform manages the
docker_image resource with the docker provider. Together, the resource type and resource name form a unique ID for the
resource. For example, the ID for your Docker image is docker_image.nginx.

Resource blocks contain arguments which you use to configure the resource. Arguments can include things like machine
sizes, disk image names, or VPC IDs.
Our [providers reference documents](https://registry.terraform.io/providers/kreuzwerker/docker/latest/docs) the required
and optional arguments for each resource. For your container, the example configuration sets the Docker image as the
image source for your
docker_container resource.

# Build infrastructure 🏗️

When you create a new configuration — or check out an existing configuration from version control — you need to
initialize the directory with terraform init.

Initializing a configuration directory downloads and installs the providers defined in the configuration, which in this
case is the docker provider.

Run:

1. `cd tools/Terraform`
2. `terraform init` - downloads all required providers
3. `terraform fmt` - format you configs, or you can use IDE plugin that can do the same
4. `terraform validate` - validate your config file
5. `terraform apply` - create infra. Before it applies any changes, Terraform prints out the execution plan. The output
   format is similar to the diff format generated by tools such as Git. After that it will wait until your approval.
   After approve Terraform wrote data into `terraform.tfstate`, this file is the only way Terraform can
   track which resources it manages, and often contains sensitive information, so you must store your state file
   securely and restrict access to only trusted team members who need to manage your infrastructure
6. `terraform show` - Inspect the current state

# Update infrastructure 🔄

Now let's update our infra. For example let's change nginx port to 8080
`external = 8000 -> external = 8080`
after run `terraform apply` again and check changes. As you can see terraform will destroy current container
and create new one since Docker it cannot change the port of a container after it has been created

In changes:

- prefix `-/+` means that Terraform will destroy and recreate the resource, rather than updating it in-place
- `~` prefix means Terraform can update some attributes in-place
- `# forces replacement` shows what change forces Terraform to re-create container

# Destroy infrastructure 🔥

Run `terraform destroy` to terminates resources managed by your Terraform project. This command is the inverse of
`terraform apply` in that it terminates all the resources specified in your Terraform state. It does not destroy
resources
running elsewhere that are not managed by the current Terraform project.

# Work with functions and variables

The current configuration includes a number of hard-coded values. Terraform variables allow you to write configuration
that is flexible and easier to re-use. But I won't cover this functionality here)

Also, you can use values from one blocks in another block, apply different functions and output them. For
example here I'm concat 2 IDs from docker image to check if they are the same

```hcl
output "image_id" {
  description = "ID and Image ID of the Docker image to compare"
  value       = format("ID: %s VS Image ID: %s", docker_image.nginx.id, docker_image.nginx.image_id)
}
```

You can see all outputs while you are running `terraform apply` or after using `terraform outputs` 